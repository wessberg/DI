{"version":3,"file":"index.js","sources":["../../src/constructor-arguments/constructor-arguments-identifier.ts","../../src/di-container/di-container.ts"],"sourcesContent":["export const CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER = `___CTOR_ARGS___`;\nexport const CONSTRUCTOR_ARGUMENTS_SYMBOL: unique symbol = Symbol.for(\n  CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER\n);\n","import { IConstructInstanceOptions } from \"../construct-instance-options/i-construct-instance-options\";\nimport { IParent } from \"../construct-instance-options/i-parent\";\nimport { CONSTRUCTOR_ARGUMENTS_SYMBOL } from \"../constructor-arguments/constructor-arguments-identifier\";\nimport { IGetOptions } from \"../get-options/i-get-options\";\nimport { IHasOptions } from \"../has-options/i-has-options\";\nimport { NewableService } from \"../newable-service/newable-service\";\nimport {\n  IRegisterOptionsWithImplementation,\n  IRegisterOptionsWithoutImplementation,\n  RegisterOptions,\n} from \"../register-options/i-register-options\";\nimport { RegistrationKind } from \"../registration-kind/registration-kind\";\nimport { IDIContainer, IDIContainerMaps } from \"./i-di-container\";\nimport { RegistrationRecord } from \"../registration-record/i-registration-record\";\nimport { ImplementationInstance } from \"../implementation/implementation\";\n\n/**\n * A Dependency-Injection container that holds services and can produce instances of them as required.\n * It mimics reflection by parsing the app at compile-time and supporting the generic-reflection syntax.\n * @author Frederik Wessberg\n */\nexport class DIContainer implements IDIContainer {\n  /**\n   * Registers a service that will be instantiated once in the application lifecycle. All requests\n   * for the service will retrieve the same instance of it.\n   *\n   * You should not pass any options to the method if using the compiler. It will do that automatically.\n   */\n  registerSingleton<T, U extends T = T>(\n    newExpression: ImplementationInstance<U>,\n    options: IRegisterOptionsWithoutImplementation\n  ): void;\n  registerSingleton<T, U extends T = T>(\n    newExpression: undefined,\n    options: IRegisterOptionsWithImplementation<U>\n  ): void;\n  registerSingleton<T, U extends T = T>(\n    newExpression?: ImplementationInstance<U> | undefined,\n    options?: RegisterOptions<U>\n  ): void;\n  registerSingleton<T, U extends T = T>(\n    newExpression?: ImplementationInstance<U> | undefined,\n    options?: RegisterOptions<U>\n  ): void {\n    if (options == null) {\n      throw new ReferenceError(\n        `2 arguments required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`\n      );\n    }\n    if (newExpression == null) {\n      return this.register(\n        \"SINGLETON\",\n        newExpression,\n        <IRegisterOptionsWithImplementation<U>>options\n      );\n    } else {\n      return this.register(\"SINGLETON\", newExpression, options);\n    }\n  }\n\n  /**\n   * Registers a service that will be instantiated every time it is requested throughout the application lifecycle.\n   * This means that every call to get() will return a unique instance of the service.\n   *\n   * You should not pass any options to the method if using the compiler. It will do that automatically.\n   */\n  registerTransient<T, U extends T = T>(\n    newExpression: ImplementationInstance<U>,\n    options: IRegisterOptionsWithoutImplementation\n  ): void;\n  registerTransient<T, U extends T = T>(\n    newExpression: undefined,\n    options: IRegisterOptionsWithImplementation<U>\n  ): void;\n  registerTransient<T, U extends T = T>(\n    newExpression?: ImplementationInstance<U> | undefined,\n    options?: RegisterOptions<U>\n  ): void;\n  registerTransient<T, U extends T = T>(\n    newExpression?: ImplementationInstance<U> | undefined,\n    options?: RegisterOptions<U>\n  ): void {\n    if (options == null) {\n      throw new ReferenceError(\n        `2 arguments required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`\n      );\n    }\n    if (newExpression == null) {\n      return this.register(\n        \"TRANSIENT\",\n        newExpression,\n        <IRegisterOptionsWithImplementation<U>>options\n      );\n    } else {\n      return this.register(\"TRANSIENT\", newExpression, options);\n    }\n  }\n\n  /**\n   * Gets an instance of the service matching the interface given as a generic type parameter.\n   * For example, 'container.get<IFoo>()' returns a concrete instance of the implementation associated with the\n   * generic interface name.\n   *\n   * You should not pass any options to the method if using the compiler. It will do that automatically.\n   */\n  get<T>(options?: IGetOptions): T {\n    if (options == null) {\n      throw new ReferenceError(\n        `1 argument required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`\n      );\n    }\n    return this.constructInstance<T>(options);\n  }\n\n  /**\n   * Returns true if a service has been registered matching the interface given as a generic type parameter.\n   * For example, 'container.get<IFoo>()' returns a concrete instance of the implementation associated with the\n   * generic interface name.\n   *\n   * You should not pass any options to the method if using the compiler. It will do that automatically.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  has<T>(options?: IHasOptions): boolean {\n    if (options == null) {\n      throw new ReferenceError(\n        `1 argument required, but only 0 present. ${DI_COMPILER_ERROR_HINT}`\n      );\n    }\n    return this.diContainerMaps.serviceRegistry.has(options.identifier);\n  }\n  /**\n   * Registers a service\n   */\n  private register<T, U extends T = T>(\n    kind: RegistrationKind,\n    newExpression: ImplementationInstance<U>,\n    options: IRegisterOptionsWithoutImplementation\n  ): void;\n  private register<T, U extends T = T>(\n    kind: RegistrationKind,\n    newExpression: undefined,\n    options: IRegisterOptionsWithImplementation<U>\n  ): void;\n  private register<T, U extends T = T>(\n    kind: RegistrationKind,\n    newExpression: ImplementationInstance<U> | undefined,\n    options: RegisterOptions<U>\n  ): void {\n    // Take all of the constructor arguments for the implementation\n    const implementationArguments =\n      \"implementation\" in options &&\n      options.implementation != null &&\n      options.implementation[CONSTRUCTOR_ARGUMENTS_SYMBOL] != null\n        ? options.implementation[CONSTRUCTOR_ARGUMENTS_SYMBOL]!\n        : [];\n    this.diContainerMaps.constructorArguments.set(options.identifier, implementationArguments);\n\n    this.diContainerMaps.serviceRegistry.set(\n      options.identifier,\n      \"implementation\" in options && options.implementation != null\n        ? { ...options, kind }\n        : { ...options, kind, newExpression: newExpression! }\n    );\n  }\n\n  /**\n   * Returns true if an instance exists that matches the given identifier.\n   */\n  private hasInstance(identifier: string): boolean {\n    return this.getInstance(identifier) != null;\n  }\n\n  /**\n   * Gets the cached instance, if any, associated with the given identifier.\n   */\n  private getInstance<T>(identifier: string): T | null {\n    const instance = this.diContainerMaps.instances.get(identifier);\n    return instance == null ? null : <T>instance;\n  }\n\n  /**\n   * Gets an IRegistrationRecord associated with the given identifier.\n   */\n  private getRegistrationRecord<T>({\n    identifier,\n    parentChain,\n  }: IConstructInstanceOptions): RegistrationRecord<T> {\n    const record = this.diContainerMaps.serviceRegistry.get(identifier);\n    if (record == null) {\n      throw new ReferenceError(\n        `${\n          this.constructor.name\n        } could not find a service for identifier: \"${identifier}\". ${\n          parentChain == null || parentChain.length < 1\n            ? \"\"\n            : `It is required by the service: '${parentChain\n                .map((parent) => parent.identifier)\n                .join(\" -> \")}'.`\n        } Remember to register it as a service!`\n      );\n    }\n    return <RegistrationRecord<T>>record;\n  }\n\n  /**\n   * Caches the given instance so that it can be retrieved in the future.\n   */\n  private setInstance<T>(identifier: string, instance: T): T {\n    this.diContainerMaps.instances.set(identifier, instance);\n    return instance;\n  }\n\n  /**\n   * Gets a lazy reference to another service\n   */\n  private getLazyIdentifier<T>(lazyPointer: () => T): T {\n    return <T>(\n      new Proxy({}, { get: (_, key: keyof T & string) => lazyPointer()[key] })\n    );\n  }\n\n  /**\n   * Constructs a new instance of the given identifier and returns it.\n   * It checks the constructor arguments and injects any services it might depend on recursively.\n   */\n  private constructInstance<T>({\n    identifier,\n    parentChain = [],\n  }: IConstructInstanceOptions): T {\n    const registrationRecord = this.getRegistrationRecord({\n      identifier,\n      parentChain,\n    });\n\n    // If an instance already exists (and it is a singleton), return that one\n    if (\n      this.hasInstance(identifier) &&\n      registrationRecord.kind === \"SINGLETON\"\n    ) {\n      return <T>this.getInstance(identifier);\n    }\n\n    // Otherwise, instantiate a new one\n    let instance: T;\n\n    const me: IParent<T> = {\n      identifier,\n      ref: this.getLazyIdentifier(() => instance),\n    };\n\n    // If a user-provided new-expression has been provided, invoke that to get an instance.\n    if (\"newExpression\" in registrationRecord) {\n      if (typeof registrationRecord.newExpression !== \"function\") {\n        throw new TypeError(\n          `Could not instantiate the service with the identifier: '${registrationRecord.identifier}': You provided a custom instantiation argument, but it wasn't of type function. It has to be a function that returns whatever should be used as an instance of the Service!`\n        );\n      }\n      try {\n        instance = registrationRecord.newExpression() as T;\n      } catch (ex) {\n        throw new Error(\n          `Could not instantiate the service with the identifier: '${registrationRecord.identifier}': When you registered the service, you provided a custom instantiation function, but it threw an exception when it was run!`\n        );\n      }\n    } else {\n      // Find the arguments for the identifier\n      const mappedArgs = this.diContainerMaps.constructorArguments.get(identifier);\n      if (mappedArgs == null) {\n        throw new ReferenceError(\n          `${this.constructor.name} could not find constructor arguments for the service: '${identifier}'. Have you registered it as a service?`\n        );\n      }\n\n      // Instantiate all of the argument services (or re-use them if they were registered as singletons)\n      const instanceArgs = mappedArgs.map((dep) => {\n        if (dep === undefined) return undefined;\n        const matchedParent = parentChain.find(\n          (parent) => parent.identifier === dep\n        );\n        if (matchedParent != null) return matchedParent.ref;\n        return this.constructInstance<T>({\n          identifier: dep,\n          parentChain: [...parentChain, me],\n        });\n      });\n\n      try {\n        // Try to construct an instance with 'new' and if it fails, call the implementation directly.\n        const newable = registrationRecord.implementation as NewableService<T>;\n        instance = new newable(...instanceArgs);\n      } catch (ex) {\n        if (registrationRecord.implementation == null) {\n          throw new ReferenceError(\n            `${this.constructor.name} could not construct a new service of kind: ${identifier}. Reason: No implementation was given!`\n          );\n        }\n        const constructable = registrationRecord.implementation;\n        // Try without 'new' and call the implementation as a function.\n        instance = (constructable as unknown as CallableFunction)(\n          ...instanceArgs\n        );\n      }\n    }\n\n    return registrationRecord.kind === \"SINGLETON\"\n      ? this.setInstance<T>(identifier, instance)\n      : instance;\n  }\n\n   /**\n   * Maps that may get defined during Moddable pre-load, and then frozen into flash memory.  See the getter\n   * `diContainerMaps` which handles the transition from flash to runtime for the maps.\n   */\n   private readonly writableDiContainerMaps: IDIContainerMaps = {\n    constructorArguments: new Map(),\n    serviceRegistry: new Map(),\n    instances: new Map()\n  };\n\n   /**\n   * Getter that provides access to the various maps.  Handles cloning the maps from the read-only preload condition\n   * to a writable runtime version to support Moddable preloads.\n   */\n   private get diContainerMaps(): IDIContainerMaps {\n    // if a map is frozen, it has been preloaded, so we need to clone the map.  This happens because registrations\n    // occur during preload, but then also need to work at runtime.\n    if (Object.isFrozen(this.writableDiContainerMaps.constructorArguments)) {\n      this.writableDiContainerMaps.constructorArguments = new Map(\n        this.writableDiContainerMaps.constructorArguments\n      );\n      this.writableDiContainerMaps.instances = new Map(\n        this.writableDiContainerMaps.instances\n      );\n      this.writableDiContainerMaps.serviceRegistry = new Map(\n        this.writableDiContainerMaps.serviceRegistry\n      );\n    }\n\n    return this.writableDiContainerMaps;\n  }\n}\n\nconst DI_COMPILER_ERROR_HINT = `Note: You must use DI-Compiler (https://github.com/wessberg/di-compiler) for this library to work correctly. Please consult the readme for instructions on how to install and configure it for your project.`;\n"],"names":[],"mappings":"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"}